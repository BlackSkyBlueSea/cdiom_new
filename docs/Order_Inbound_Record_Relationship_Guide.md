# 订单与入库记录关系说明

## 一、数据库表关系

### 1.1 表结构关系

```
purchase_order (采购订单主表)
    ├── id (主键)
    ├── order_number (订单编号，唯一)
    ├── supplier_id (供应商ID，外键)
    ├── purchaser_id (采购员ID，外键)
    ├── status (订单状态)
    └── ...

purchase_order_item (采购订单明细表)
    ├── id (主键)
    ├── order_id (订单ID，外键 → purchase_order.id)
    ├── drug_id (药品ID，外键 → drug_info.id)
    ├── quantity (采购数量)
    └── ...

inbound_record (入库记录表)
    ├── id (主键)
    ├── record_number (入库单号，唯一)
    ├── order_id (关联采购订单ID，外键 → purchase_order.id，可为NULL)
    ├── drug_id (药品ID，外键 → drug_info.id)
    ├── batch_number (批次号)
    ├── quantity (入库数量)
    └── ...
```

### 1.2 关系说明

**一对多关系**：
- 一个采购订单（`purchase_order`）可以对应多个入库记录（`inbound_record`）
- 一个采购订单（`purchase_order`）可以包含多个订单明细（`purchase_order_item`）
- 一个入库记录（`inbound_record`）只能关联一个采购订单（`purchase_order`），也可以为空（临时入库）

**业务逻辑**：
1. **采购订单入库**：`inbound_record.order_id` 不为空，关联到具体的采购订单
2. **临时入库**：`inbound_record.order_id` 为空，不关联任何订单

### 1.3 订单状态流转

```
PENDING (待确认) 
  → REJECTED (已拒绝) 或 
  → CONFIRMED (待发货) 
    → SHIPPED (已发货) 
      → RECEIVED (已入库) 或 
      → CANCELLED (已取消)
```

**状态说明**：
- **PENDING**：订单已创建，等待供应商确认
- **REJECTED**：供应商拒绝订单
- **CONFIRMED**：供应商确认订单，准备发货
- **SHIPPED**：供应商已发货，可以开始入库验收
- **RECEIVED**：订单全部入库完成
- **CANCELLED**：订单已取消

### 1.4 入库与订单的关系

**部分入库**：
- 一个订单可以分多次入库（支持分批到货）
- 每次入库创建一条 `inbound_record` 记录
- 所有入库记录的 `quantity` 总和不能超过订单明细的 `quantity`

**订单状态更新规则**：
- 当订单首次入库时，订单状态保持 `SHIPPED`
- 当订单全部入库完成时（所有明细的已入库数量 = 采购数量），订单状态更新为 `RECEIVED`

---

## 二、订单条形码生成方案

### 2.1 条形码内容设计

**方案一：使用订单编号（推荐）**
- 条形码内容：直接使用 `order_number`（订单编号）
- 优点：简单直接，扫描后可直接查询订单
- 格式：`PO20260112001`（PO + 日期 + 序号）

**方案二：使用订单ID编码**
- 条形码内容：`PO{订单ID}`，如 `PO123`
- 优点：更短，扫描速度快
- 缺点：需要解析后才能查询订单

**推荐使用方案一**，因为订单编号本身具有唯一性和可读性。

### 2.2 条形码格式

**Code128格式**（推荐）：
- 支持字母和数字
- 密度高，扫描速度快
- 适合打印在标签上

**Code39格式**（备选）：
- 支持字母、数字和部分特殊字符
- 密度较低，但兼容性好

### 2.3 条形码生成位置

1. **订单创建时**：自动生成订单编号，同时生成条形码
2. **订单详情页面**：显示条形码，支持打印
3. **订单列表页面**：支持批量打印条形码

### 2.4 条形码扫描流程

```
扫描订单条形码 
  → 解析订单编号 
    → 查询订单信息（purchase_order + purchase_order_item）
      → 显示订单详情和明细
        → 选择需要入库的药品
          → 填写入库信息
            → 执行入库操作
```

---

## 三、入库验收流程设计

### 3.1 方式一：扫描订单条形码入库

**流程**：
1. 仓库管理员进入"入库管理"页面
2. 点击"扫描订单条形码"按钮
3. 扫描订单条形码（或手动输入订单编号）
4. 系统自动查询订单信息：
   - 显示订单基本信息（订单编号、供应商、采购员、订单日期等）
   - 显示订单明细列表（药品名称、规格、采购数量、已入库数量、待入库数量）
5. 选择需要入库的药品明细
6. 填写入库信息（批次号、生产日期、有效期、入库数量等）
7. 执行效期校验
8. 特殊药品双人确认
9. 提交入库

### 3.2 方式二：选择订单列表入库

**流程**：
1. 仓库管理员进入"入库管理"页面
2. 点击"选择订单"按钮
3. 显示订单列表（筛选条件：状态=SHIPPED）
4. 选择需要入库的订单
5. 显示订单详情和明细
6. 后续流程同方式一（步骤5-9）

### 3.3 入库信息自动填充

**从订单明细自动填充**：
- 药品信息（药品名称、规格、剂型等）
- 生产厂家（从药品信息表获取）
- 采购数量（从订单明细获取）
- 待入库数量（采购数量 - 已入库数量）

**需要手动填写**：
- 批次号（必填）
- 生产日期（必填）
- 有效期至（必填，可根据生产日期和药品有效期自动计算）
- 入库数量（必填，不能超过待入库数量）
- 存储位置（必填）
- 随货同行单编号（可选）
- 随货同行单图片（可选）

---

## 四、数据流转关系

### 4.1 订单创建 → 入库验收 → 库存更新

```
1. 创建采购订单
   purchase_order (订单主表)
   purchase_order_item (订单明细表)

2. 供应商发货，订单状态更新为 SHIPPED

3. 到货验收，创建入库记录
   inbound_record (入库记录表)
   - order_id: 关联订单ID
   - drug_id: 药品ID
   - quantity: 入库数量
   - batch_number: 批次号
   - ...

4. 更新库存
   inventory (库存表)
   - 如果批次已存在：quantity += 入库数量
   - 如果批次不存在：新增库存记录

5. 更新订单状态
   - 计算已入库数量
   - 如果全部入库：status = RECEIVED
   - 如果部分入库：status = SHIPPED（保持不变）
```

### 4.2 已入库数量计算

**计算逻辑**：
```sql
-- 查询订单某个药品明细的已入库数量
SELECT COALESCE(SUM(quantity), 0) as inbound_quantity
FROM inbound_record
WHERE order_id = ? AND drug_id = ?
  AND status = 'QUALIFIED'  -- 只统计合格入库的数量
```

**待入库数量**：
```
待入库数量 = 采购数量 - 已入库数量
```

---

## 五、业务规则

### 5.1 订单入库规则

1. **订单状态限制**：只有状态为 `SHIPPED` 的订单才能进行入库操作
2. **入库数量限制**：单次入库数量不能超过订单明细的待入库数量
3. **批次管理**：同一药品同一批次在库存表中唯一
4. **部分入库**：支持订单分多次入库，每次入库创建独立的入库记录

### 5.2 订单状态更新规则

1. **首次入库**：订单状态保持 `SHIPPED`
2. **全部入库**：当所有明细的已入库数量 = 采购数量时，订单状态更新为 `RECEIVED`
3. **订单取消**：如果订单被取消，不能再进行入库操作

### 5.3 数据完整性

1. **外键约束**：`inbound_record.order_id` 外键关联 `purchase_order.id`，删除订单时设置为NULL
2. **唯一约束**：`inbound_record.record_number` 唯一，`purchase_order.order_number` 唯一
3. **非负约束**：入库数量必须 > 0

---

## 六、实现建议

### 6.1 后端实现

1. **订单查询接口**：
   - `GET /api/v1/purchase-orders?status=SHIPPED` - 查询可入库的订单列表
   - `GET /api/v1/purchase-orders/{orderNumber}` - 根据订单编号查询订单详情（用于条形码扫描）

2. **入库接口**：
   - `POST /api/v1/inbound-records` - 创建入库记录
   - `GET /api/v1/inbound-records?orderId={orderId}` - 查询订单的入库记录

3. **已入库数量计算**：
   - 在Service层实现已入库数量计算逻辑
   - 在订单详情接口中返回已入库数量和待入库数量

### 6.2 前端实现

1. **条形码扫描组件**：
   - 使用扫码枪或摄像头扫描条形码
   - 解析订单编号，调用后端接口查询订单信息

2. **入库验收页面**：
   - 显示订单基本信息
   - 显示订单明细列表（包含已入库数量、待入库数量）
   - 入库表单（批次号、生产日期、有效期、入库数量等）
   - 效期校验提示
   - 特殊药品双人确认

3. **订单列表页面**：
   - 显示订单列表（支持筛选状态=SHIPPED）
   - 点击订单进入入库验收页面

### 6.3 条形码生成

**后端生成条形码图片**：
- 使用Java库（如 `barcode4j`）生成条形码图片
- 接口：`GET /api/v1/purchase-orders/{id}/barcode` - 返回条形码图片

**前端显示和打印**：
- 使用 `react-barcode` 或类似库在前端生成条形码
- 支持打印功能

---

**文档版本**：v1.0  
**最后更新**：2026年1月13日  
**文档作者**：CDIOM开发团队

