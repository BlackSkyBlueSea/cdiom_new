# 代码逻辑漏洞检查报告

## 文档信息

**文档创建时间**：2026年1月14日 14:43:05  
**最后修改时间**：2026年1月14日 16:14:48  
**当前检查时间**：2026年1月14日 16:17:17  
**文档版本**：v2.0

## 检查时间
2026年1月14日（最新更新）

## 检查范围
- 后端业务逻辑代码
- 前端业务逻辑代码
- 安全漏洞
- 并发安全问题
- 数据一致性问题
- 异常处理完整性

---

## 🔴 严重问题（需要立即修复）

### 1. 登录锁定机制未实现 ⚠️ **严重**

**问题位置**：`cdiom_backend/src/main/java/com/cdiom/backend/service/impl/AuthServiceImpl.java`

**问题描述**：
- `login` 方法中**没有检查用户是否被锁定**（`lockTime` 字段）
- **没有更新登录失败次数**（`loginFailCount` 字段）
- **没有实现锁定逻辑**（连续5次失败锁定1小时）

**当前代码**：
```java
// 第60-66行：只检查了用户是否存在和密码是否正确，但没有检查锁定状态
if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
    loginLog.setStatus(0);
    loginLog.setMsg("用户名或密码错误");
    loginLogService.saveLog(loginLog);
    throw new RuntimeException("用户名或密码错误");
}
```

**修复建议**：
1. 在检查用户状态之前，先检查 `lockTime` 是否在1小时内
2. 如果用户被锁定且未到解锁时间，直接拒绝登录
3. 如果密码错误，增加 `loginFailCount`，如果达到5次，设置 `lockTime`
4. 如果登录成功，重置 `loginFailCount` 和 `lockTime`

**影响**：用户账户安全无法保障，无法防止暴力破解攻击

---

### 2. 库存操作并发安全问题 ✅ **已修复**

**问题位置**：
- `cdiom_backend/src/main/java/com/cdiom/backend/service/impl/InventoryServiceImpl.java`
  - `increaseInventory` 方法（第121-143行）
  - `decreaseInventory` 方法（第146-178行）
  - `updateInventoryQuantity` 方法（第181-196行）

**修复状态**：✅ **已修复**

**修复方案**：
1. ✅ 使用**悲观锁**：在查询时使用 `SELECT ... FOR UPDATE`（`inventoryMapper.selectForUpdate`）
2. ✅ 使用**原子更新操作**：
   - `insertOrUpdateInventory`：使用 `INSERT ... ON DUPLICATE KEY UPDATE` 原子操作
   - `decreaseQuantityAtomically`：使用 `UPDATE ... WHERE quantity >= #{quantity}` 原子更新

**当前代码**：
```java
// 第137行：使用悲观锁查询库存
Inventory inventory = inventoryMapper.selectForUpdate(drugId, batchNumber);

// 第129行：使用原子更新操作增加库存
int affectedRows = inventoryMapper.insertOrUpdateInventory(drugId, batchNumber, quantity, ...);

// 第165行：使用原子更新操作减少库存
int affectedRows = inventoryMapper.decreaseQuantityAtomically(drugId, batchNumber, quantity);
```

**验证结果**：✅ **已通过**
- 库存操作已使用悲观锁和原子更新，确保并发安全
- 不会出现库存超卖或库存不一致问题

---

### 3. 单号生成并发问题 ⚠️ **严重**

**问题位置**：
- `InboundRecordServiceImpl.generateRecordNumber()`（第280-290行）
- `OutboundApplyServiceImpl.generateApplyNumber()`（第304-314行）
- `InventoryAdjustmentServiceImpl.generateAdjustmentNumber()`（第140-150行）

**问题描述**：
- 单号生成逻辑在**并发情况下可能生成重复的单号**
- 查询当天数量和使用 `count + 1` 的方式不是原子操作

**当前代码**：
```java
// 第287行：查询今天已生成的入库单数量
long count = inboundRecordMapper.selectCount(wrapper);
// 第288行：使用 count + 1，但这不是原子操作
String sequence = String.format("%03d", count + 1);
```

**修复建议**：
1. 使用**数据库序列**或**自增ID**生成单号
2. 或者使用**分布式锁**（Redis）确保单号生成的唯一性
3. 或者在数据库层面使用**唯一索引**，捕获重复异常后重试

**影响**：可能导致单号重复，影响业务数据唯一性

---

## 🟡 中等问题（建议修复）

### 4. 出库逻辑中FIFO批次选择可能不足

**问题位置**：`OutboundApplyServiceImpl.executeOutbound()`（第232-248行）

**问题描述**：
- `getAvailableBatches` 方法返回的批次可能**数量不足**
- 如果累计数量不足，会抛出异常，但此时可能已经扣减了部分库存

**当前代码**：
```java
// 第233行：获取可用批次
List<Inventory> availableBatches = inventoryService.getAvailableBatches(drugId, actualQuantity);
// 第236-244行：循环扣减库存
for (Inventory batch : availableBatches) {
    // ... 扣减库存
}
// 第246行：如果剩余数量>0，抛出异常，但此时可能已经扣减了部分库存
if (remainingQuantity > 0) {
    throw new RuntimeException("库存不足...");
}
```

**修复建议**：
1. 在扣减库存之前，先验证所有批次的总数量是否足够
2. 或者使用事务回滚，确保部分扣减时能够回滚

**影响**：可能导致部分库存被扣减但出库失败，需要手动调整

---

### 5. 入库数量验证缺失 ✅ **已修复**

**问题位置**：`InboundRecordServiceImpl.createInboundRecordFromOrder()`（第135-159行）

**修复状态**：✅ **已修复**

**修复方案**：
1. ✅ 实现了入库数量验证逻辑
2. ✅ 查询订单明细的采购数量和已入库数量
3. ✅ 确保本次入库数量加上已入库数量不超过订单采购数量

**当前代码**：
```java
// 第135-159行：已实现入库数量验证
// 获取已入库数量（只统计验收合格的）
Integer existingInboundQuantity = getInboundQuantityByOrderAndDrug(orderId, drugId);
if (existingInboundQuantity == null) {
    existingInboundQuantity = 0;
}

// 检查本次入库数量加上已入库数量是否超过订单采购数量
Integer totalInboundQuantity = existingInboundQuantity + inboundRecord.getQuantity();
if (totalInboundQuantity > orderItem.getQuantity()) {
    throw new RuntimeException(String.format(
        "入库数量超过订单采购数量。订单采购数量：%d，已入库数量：%d，本次入库数量：%d，总计：%d",
        orderItem.getQuantity(), existingInboundQuantity, inboundRecord.getQuantity(), totalInboundQuantity
    ));
}
```

**验证结果**：✅ **已通过**
- 入库数量验证逻辑已实现，确保不会超过订单采购数量

---

### 6. 订单状态更新缺失 ✅ **已修复**

**问题位置**：`InboundRecordServiceImpl.createInboundRecordFromOrder()`（第201-203行）

**修复状态**：✅ **已修复**

**修复方案**：
1. ✅ 实现了订单状态更新逻辑
2. ✅ 调用 `purchaseOrderService.updateOrderInboundStatus(orderId)` 方法
3. ✅ 在 `PurchaseOrderServiceImpl.updateOrderInboundStatus()` 中检查是否全部入库，如果全部入库则更新订单状态为 RECEIVED

**当前代码**：
```java
// 第201-203行：已实现订单状态更新
// 更新订单状态（检查是否全部入库）
purchaseOrderService.updateOrderInboundStatus(orderId);
```

```java
// PurchaseOrderServiceImpl.updateOrderInboundStatus() 方法
@Override
@Transactional(rollbackFor = Exception.class)
public void updateOrderInboundStatus(Long orderId) {
    if (isOrderFullyInbound(orderId)) {
        updateOrderStatus(orderId, "RECEIVED", null);
        log.info("订单全部入库完成：订单ID={}", orderId);
    }
}
```

**验证结果**：✅ **已通过**
- 订单状态更新逻辑已实现，入库完成后自动检查并更新订单状态

---

## 🟢 轻微问题（可选修复）

### 7. 异常信息暴露

**问题位置**：多个 Service 实现类

**问题描述**：
- 部分异常信息可能暴露内部实现细节
- 例如：`"库存不足，当前库存：" + inventory.getQuantity() + "，需要出库：" + quantity`

**修复建议**：
1. 在生产环境中，使用更通用的错误信息
2. 详细错误信息记录到日志中，不返回给前端

**影响**：可能泄露系统内部信息，但影响较小

---

### 8. 数据验证不完整

**问题位置**：部分 Controller 和 Service

**问题描述**：
- 部分接口缺少参数验证
- 例如：`OutboundApplyServiceImpl.createOutboundApply()` 中，items 的类型转换没有验证

**当前代码**：
```java
// 第112行：直接类型转换，没有验证
applyItem.setDrugId(Long.valueOf(item.get("drugId").toString()));
```

**修复建议**：
1. 添加参数验证
2. 使用 Bean Validation 注解
3. 添加类型转换异常处理

**影响**：可能导致运行时异常，但影响较小

---

## ✅ 已验证的安全措施

### 1. SQL注入防护 ✅
- 使用 MyBatis-Plus 的 `LambdaQueryWrapper`，所有查询都是参数化查询
- 没有发现直接拼接SQL字符串的情况

### 2. 密码加密 ✅
- 使用 BCrypt 加密，强度10轮
- 密码不会明文存储

### 3. 权限控制 ✅
- 使用 `@RequiresPermission` 注解进行权限控制
- 权限拦截器已实现

### 4. 事务管理 ✅
- 关键业务操作都使用了 `@Transactional` 注解
- 异常回滚配置正确

---

## 📋 修复优先级

### 立即修复（P0）
1. ❌ **登录锁定机制未实现**（仍需修复）
2. ✅ 库存操作并发安全问题（**已修复**）
3. ⚠️ 单号生成并发问题（**仍存在，建议修复**）

### 尽快修复（P1）
4. ⚠️ 出库逻辑中FIFO批次选择可能不足（**建议优化**）
5. ✅ 入库数量验证缺失（**已修复**）
6. ✅ 订单状态更新缺失（**已修复**）

### 可选修复（P2）
7. ✅ 异常信息暴露
8. ✅ 数据验证不完整

---

## 🔧 修复建议总结

### 1. 登录锁定机制
```java
// 在 AuthServiceImpl.login() 方法中添加：
// 1. 检查锁定状态
if (user.getLockTime() != null) {
    LocalDateTime unlockTime = user.getLockTime().plusHours(1);
    if (LocalDateTime.now().isBefore(unlockTime)) {
        throw new RuntimeException("账户已被锁定，请稍后再试");
    }
}

// 2. 密码错误时更新失败次数
if (!passwordEncoder.matches(password, user.getPassword())) {
    int failCount = (user.getLoginFailCount() == null ? 0 : user.getLoginFailCount()) + 1;
    user.setLoginFailCount(failCount);
    if (failCount >= 5) {
        user.setLockTime(LocalDateTime.now());
    }
    sysUserMapper.updateById(user);
    // ... 记录日志并抛出异常
}

// 3. 登录成功时重置
user.setLoginFailCount(0);
user.setLockTime(null);
sysUserMapper.updateById(user);
```

### 2. 库存并发安全 ✅ **已修复**
```java
// 已在 InventoryMapper 中实现：
@Select("SELECT * FROM inventory WHERE drug_id = #{drugId} AND batch_number = #{batchNumber} FOR UPDATE")
Inventory selectForUpdate(@Param("drugId") Long drugId, @Param("batchNumber") String batchNumber);

// 已在 InventoryServiceImpl 中使用：
Inventory inventory = inventoryMapper.selectForUpdate(drugId, batchNumber);

// 使用原子更新操作：
@Update("UPDATE inventory SET quantity = quantity - #{quantity} WHERE drug_id = #{drugId} AND batch_number = #{batchNumber} AND quantity >= #{quantity}")
int decreaseQuantityAtomically(@Param("drugId") Long drugId, @Param("batchNumber") String batchNumber, @Param("quantity") Integer quantity);
```

### 3. 单号生成
```java
// 使用数据库自增ID + 日期生成单号
// 或者使用 Redis 分布式锁
// 或者在数据库层面添加唯一索引，捕获重复异常后重试
```

---

**最后更新**：2026年1月14日 16:17:17  
**检查人员**：代码审查系统

---

## 文件变更历史

| 版本 | 日期 | 修改内容 |
|------|------|----------|
| v1.0 | 2026-01-14 14:43:05 | 初始版本创建，记录登录锁定、库存并发、单号生成等严重问题 |
| v2.0 | 2026-01-14 16:14:48 | 更新修复状态：库存并发安全、入库数量验证、订单状态更新已修复 |
| v2.1 | 2026-01-14 16:17:17 | 添加文档时间记录和文件变更历史 |

---

## 📊 修复进度总结

### ✅ 已修复的问题（3个）
1. ✅ 库存操作并发安全问题 - 已使用悲观锁和原子更新操作
2. ✅ 入库数量验证缺失 - 已实现入库数量验证逻辑
3. ✅ 订单状态更新缺失 - 已实现订单状态自动更新逻辑

### ❌ 仍需修复的问题（1个严重问题）
1. ❌ **登录锁定机制未实现** - 需要立即修复
   - 未检查用户锁定状态（lockTime）
   - 未更新登录失败次数（loginFailCount）
   - 未实现锁定逻辑（连续5次失败锁定1小时）

### ⚠️ 建议优化的问题（2个）
1. ⚠️ **单号生成并发问题** - 建议使用数据库唯一索引+重试机制或分布式锁
2. ⚠️ **出库逻辑中FIFO批次选择可能不足** - 建议在扣减前先验证总数量是否足够

